// ================================================
// This file contains all the frontend (actual website) code for handling user MIDI input
// ================================================

// Connection to Node.JS
let socket = io();

// Container for note on events that user records
let noteOns = new Map();

// Start time - reset every time the user hits record
let START = Date.now();
// Recording state
let isRecording = false;

// Placeholder for the soundfont instrument to playback MIDI live as the user records it
let piano;

$(document).ready(function() {
    // Enable WebMidi (for MIDI recording), then do everything else
    WebMidi.enable(function (err) {
        if (err) {
            console.log("WebMidi could not be enabled.", err);
        } else {
            console.log("WebMidi enabled!");
        }

        // Log MIDI ins and outs
        console.log("MIDI inputs: ", WebMidi.inputs);
        console.log("MIDI outputs: ", WebMidi.outputs);

        // Add note-on and note-off MIDI listeners for ALL connected MIDI inputs
        for(let i = 0; i < WebMidi.inputs.length; i++){
            let input = WebMidi.inputs[i];
            input.addListener('noteon', "all",
                function (e) {
                    console.log("Received 'noteon' message (" + e.note.name + e.note.octave + ").");
                    // Start timing
                    // e.g. "E4"
                    let noteName = e.note.name + e.note.octave;
                    noteOns.set(noteName, Date.now());
                }
            );
            input.addListener('noteoff', "all",
                function (e) {
                    console.log("Received 'noteoff' message (" + e.note.name + e.note.octave + ").");
                    let noteName = e.note.name + e.note.octave;
                    let start = noteOns.get(noteName);
                    // Get note duration in ms
                    let duration = Date.now() - start;
                    let relativeStart = start - START;
                    console.log("Time diff in ms: ", duration);
                    // Send new note to Node.JS -> there it's written into the MIDI track
                    socket.emit('new_note', noteName, relativeStart, duration)
                    // Remove from currently tracked notes so it can be triggered again
                    noteOns.delete(e.note.name);
                }
            );
        }
    });

    // Manage record button click
    $('#recordButton').click(() => {
        // If not currently recording trigger new recording
        if(!isRecording){
            // Change button appearance
            $('#recordButton').stop().animate({backgroundColor:'green'}, 300);
            $('#recordButton').removeClass('red');
            $('#recordButton').addClass('green');

            // Set recording state
            isRecording = true;
            // Reset time
            START = Date.now();
            // Clear notes
            noteOns.clear();
            // Trigger new track on Node.JS
            socket.emit('new_track');
        }
        // If currently recording, end recording and
        else {
            // Change button appearance
            $('#recordButton').stop().animate({backgroundColor:'#eb4d4b'}, 300);
            $('#recordButton').removeClass('green');
            $('#recordButton').addClass('red');

            // Set recording state
            isRecording = false;
            // Trigger writing process of actual *.mid file on Node.JS
            socket.emit('write_midi');
            // Change button text while new bars are being generated by the python backend
            $('#generateBtn').text("Generating from recorded...");
        }

        // Start sound font piano for user WebMIDI playback
        // This has to be inside of a button click event due to the new
        // browser policies on starting AudioContexts with user events.
        // For details see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy
        Soundfont.instrument(new AudioContext(), 'acoustic_grand_piano').then(function (p) {
            piano = p;
            // Get MIDI access via browser
            window.navigator.requestMIDIAccess().then(function (midiAccess) {
                // Listen to EACH MIDI input
                // Could be changed to MIDI input selector in the future
                midiAccess.inputs.forEach(function (midiInput) {
                    piano.listenToMidi(midiInput);
                })
            })
        });
    });
});